#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
typedef  int uint8_t ;
typedef  int uint32_t ;
typedef  int u_int ;
struct ahc_softc {int /*<<< orphan*/  dev_softc; int /*<<< orphan*/  flags; } ;

/* Variables and functions */
 int /*<<< orphan*/  AHC_NO_BIOS_INIT ; 
 int CHIPRST ; 
 int /*<<< orphan*/  CLRINT ; 
 int CLRPARERR ; 
 int EIO ; 
 int FAILDIS ; 
 int /*<<< orphan*/  HCNTRL ; 
 int PAUSE ; 
 int PCIM_CMD_SERRESPEN ; 
 scalar_t__ PCIR_COMMAND ; 
 scalar_t__ PCIR_STATUS ; 
 int PERRORDIS ; 
 int /*<<< orphan*/  SCBPTR ; 
 int /*<<< orphan*/  SCB_BASE ; 
 int /*<<< orphan*/  SEQCTL ; 
 int STA ; 
 int ahc_inb (struct ahc_softc*,int /*<<< orphan*/ ) ; 
 int ahc_inl (struct ahc_softc*,int /*<<< orphan*/ ) ; 
 scalar_t__ ahc_is_paused (struct ahc_softc*) ; 
 int /*<<< orphan*/  ahc_outb (struct ahc_softc*,int /*<<< orphan*/ ,int) ; 
 int /*<<< orphan*/  ahc_outl (struct ahc_softc*,int /*<<< orphan*/ ,int) ; 
 int ahc_pci_read_config (int /*<<< orphan*/ ,scalar_t__,int) ; 
 int /*<<< orphan*/  ahc_pci_write_config (int /*<<< orphan*/ ,scalar_t__,int,int) ; 

int
ahc_pci_test_register_access(struct ahc_softc *ahc)
{
	int	 error;
	u_int	 status1;
	uint32_t cmd;
	uint8_t	 hcntrl;

	error = EIO;

	/*
	 * Enable PCI error interrupt status, but suppress NMIs
	 * generated by SERR raised due to target aborts.
	 */
	cmd = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/2);
	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,
			     cmd & ~PCIM_CMD_SERRESPEN, /*bytes*/2);

	/*
	 * First a simple test to see if any
	 * registers can be read.  Reading
	 * HCNTRL has no side effects and has
	 * at least one bit that is guaranteed to
	 * be zero so it is a good register to
	 * use for this test.
	 */
	hcntrl = ahc_inb(ahc, HCNTRL);

	if (hcntrl == 0xFF)
		goto fail;

	if ((hcntrl & CHIPRST) != 0) {
		/*
		 * The chip has not been initialized since
		 * PCI/EISA/VLB bus reset.  Don't trust
		 * "left over BIOS data".
		 */
		ahc->flags |= AHC_NO_BIOS_INIT;
	}

	/*
	 * Next create a situation where write combining
	 * or read prefetching could be initiated by the
	 * CPU or host bridge.  Our device does not support
	 * either, so look for data corruption and/or flagged
	 * PCI errors.  First pause without causing another
	 * chip reset.
	 */
	hcntrl &= ~CHIPRST;
	ahc_outb(ahc, HCNTRL, hcntrl|PAUSE);
	while (ahc_is_paused(ahc) == 0)
		;

	/* Clear any PCI errors that occurred before our driver attached. */
	status1 = ahc_pci_read_config(ahc->dev_softc,
				      PCIR_STATUS + 1, /*bytes*/1);
	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
			     status1, /*bytes*/1);
	ahc_outb(ahc, CLRINT, CLRPARERR);

	ahc_outb(ahc, SEQCTL, PERRORDIS);
	ahc_outb(ahc, SCBPTR, 0);
	ahc_outl(ahc, SCB_BASE, 0x5aa555aa);
	if (ahc_inl(ahc, SCB_BASE) != 0x5aa555aa)
		goto fail;

	status1 = ahc_pci_read_config(ahc->dev_softc,
				      PCIR_STATUS + 1, /*bytes*/1);
	if ((status1 & STA) != 0)
		goto fail;

	error = 0;

fail:
	/* Silently clear any latched errors. */
	status1 = ahc_pci_read_config(ahc->dev_softc,
				      PCIR_STATUS + 1, /*bytes*/1);
	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
			     status1, /*bytes*/1);
	ahc_outb(ahc, CLRINT, CLRPARERR);
	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
	return (error);
}