#define NULL ((void*)0)
typedef unsigned long size_t;  // Customize by platform.
typedef long intptr_t; typedef unsigned long uintptr_t;
typedef long scalar_t__;  // Either arithmetic or pointer type.
/* By default, we understand bool (as a convenience). */
typedef int bool;
#define false 0
#define true 1

/* Forward declarations */

/* Type definitions */
struct ppp_config {int unit; int ifname_is_set; struct file* file; } ;
struct nlattr {int dummy; } ;
struct netlink_ext_ack {int dummy; } ;
struct net_device {int dummy; } ;
struct net {int dummy; } ;
struct file {scalar_t__ private_data; int /*<<< orphan*/ * f_op; } ;

/* Variables and functions */
 int EBADF ; 
 int EBUSY ; 
 size_t IFLA_IFNAME ; 
 size_t IFLA_PPP_DEV_FD ; 
 struct file* fget (int /*<<< orphan*/ ) ; 
 int /*<<< orphan*/  fput (struct file*) ; 
 int /*<<< orphan*/  mutex_trylock (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  mutex_unlock (int /*<<< orphan*/ *) ; 
 int /*<<< orphan*/  nla_get_s32 (struct nlattr*) ; 
 int ppp_dev_configure (struct net*,struct net_device*,struct ppp_config*) ; 
 int /*<<< orphan*/  ppp_device_fops ; 
 int /*<<< orphan*/  ppp_mutex ; 

__attribute__((used)) static int ppp_nl_newlink(struct net *src_net, struct net_device *dev,
			  struct nlattr *tb[], struct nlattr *data[],
			  struct netlink_ext_ack *extack)
{
	struct ppp_config conf = {
		.unit = -1,
		.ifname_is_set = true,
	};
	struct file *file;
	int err;

	file = fget(nla_get_s32(data[IFLA_PPP_DEV_FD]));
	if (!file)
		return -EBADF;

	/* rtnl_lock is already held here, but ppp_create_interface() locks
	 * ppp_mutex before holding rtnl_lock. Using mutex_trylock() avoids
	 * possible deadlock due to lock order inversion, at the cost of
	 * pushing the problem back to userspace.
	 */
	if (!mutex_trylock(&ppp_mutex)) {
		err = -EBUSY;
		goto out;
	}

	if (file->f_op != &ppp_device_fops || file->private_data) {
		err = -EBADF;
		goto out_unlock;
	}

	conf.file = file;

	/* Don't use device name generated by the rtnetlink layer when ifname
	 * isn't specified. Let ppp_dev_configure() set the device name using
	 * the PPP unit identifer as suffix (i.e. ppp<unit_id>). This allows
	 * userspace to infer the device name using to the PPPIOCGUNIT ioctl.
	 */
	if (!tb[IFLA_IFNAME])
		conf.ifname_is_set = false;

	err = ppp_dev_configure(src_net, dev, &conf);

out_unlock:
	mutex_unlock(&ppp_mutex);
out:
	fput(file);

	return err;
}